### Графики нагрузочного тестирования до построения индекса:

#### 1 Поток
![Screenshot 2024-03-26 at 04.55.39.png](Screenshot%202024-03-26%20at%2004.55.39.png)

#### 10 потоков
![Screenshot 2024-03-26 at 05.11.48.png](Screenshot%202024-03-26%20at%2005.11.48.png)

#### 100 потоков
![Screenshot 2024-03-26 at 05.18.09.png](Screenshot%202024-03-26%20at%2005.18.09.png)

#### 1000 потоков
![Screenshot 2024-03-26 at 05.24.57.png](Screenshot%202024-03-26%20at%2005.24.57.png)

### После построения индекса

#### 1 Поток
![Screenshot 2024-03-26 at 05.32.07.png](Screenshot%202024-03-26%20at%2005.32.07.png)

#### 10 Потоков
![Screenshot 2024-03-26 at 05.38.53.png](Screenshot%202024-03-26%20at%2005.38.53.png)

#### 100 Потоков
![Screenshot 2024-03-26 at 05.46.04.png](Screenshot%202024-03-26%20at%2005.46.04.png)

#### 1000 Потоков
![Screenshot 2024-03-26 at 05.52.38.png](Screenshot%202024-03-26%20at%2005.52.38.png)


Для поиска по пользователям выбрал B-tree индекс create index ix_users on users (second_name collate "C", first_name collate "C");
B-tree индекс подходит для поиска по префиксу.
Учтена селективность колонок, сначала second_name потом first_name.
Добавил collate так как тут не важны языковые особенности.

Нагрузочное тестирование делал с помощью утилиты jmeter, метрики собирались в VictoriaMetrics и визуализировались в Grafan'e

По графикам видно многократное увеличение производительности приложения после добавления индекса.